#define dbl double
#define MAX_SIZE 1000

const dbl PI = 2.0*acos(0.0);
const dbl EPS = 1e-9; //too small/big???
dbl DEG_to_RAD(dbl d) { return d * PI / 180.0; }
dbl RAD_to_DEG(dbl r) { return r * 180.0 / PI; }

struct pt {
	dbl x,y;
	dbl length() { return sqrt(x*x+y*y); }
	dbl dist2() { return x*x + y*y; }
	
	int normalize(){
		dbl l = length();
		if(fabs(l)<EPS) return -1;
		x/=l; y/=l;
		return 0;
	}
	pt operator-(pt a){
		return {x-a.x , y-a.y};
	}
	pt operator+(pt a){
		return {x+a.x , y+a.y};
	}
	pt operator*(dbl sc){
		return {x*sc , y*sc};
	}
	pt operator/(dbl sc){
		return {x/sc , y/sc};
	}
	dbl cross(pt p) { return x*p.y - y*p.x; }
	dbl cross(pt a, pt b) { return (a-*this).cross(b-*this); }
	dbl dot(pt p) { return x*p.x + y*p.y; }
	
	pt perp() { return {-y, x}; }
	
	bool operator == (pt a){
		return x==a.x && y==a.y;
	}
};
bool operator<(const pt& a,const pt& b){
	if(fabs(a.x-b.x)<EPS) return a.y<b.y;
	return a.x<b.x;
}
dbl dist(pt& a, pt& b){
	return sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));
}
inline dbl dot(pt a, pt b){
	return(a.x*b.x+a.y*b.y);
}

void show(pt& p){
	cout << "(" << p.x << ", " << p.y << ")" << endl;
}
void show(vector<pt>& p){
	int i,n=p.size();
	for(i=0;i<n;i++) show(p[i]); 
	cout << ":)" << endl;
}

double trap(pt a, pt b){
	return (0.5*(b.x - a.x)*(b.y + a.y));
}

double triarea(pt a, pt b, pt c){
	return fabs(trap(a,b)+trap(b,c)+trap(c,a));
}

 // POINTS AND LINES
int intersection(pt p1, pt p2, pt p3, pt p4, pt &r ){
	// two lines given by $p_1\rightarrow p_2$, $p_3 \rightarrow p_4$, r is the intersection point
	// returns: $-1$ if two lines are parallel
	
	dbl d = (p4.y - p3.y)*(p2.x-p1.x) - (p4.x - p3.x)*(p2.y - p1.y);
	if( fabs( d ) < EPS ) return -1; 
	// might need to do something special!!!

	dbl ua /*, ub*/;
	ua = (p4.x - p3.x)*(p1.y-p3.y) - (p4.y-p3.y)*(p1.x-p3.x);
	ua /= d;
	// ub = (p2.x - p1.x)*(p1.y-p3.y) - (p2.y-p1.y)*(p1.x-p3.x);
	//ub /= d;
	r = p1 + (p2-p1)*ua;
	return 0;
}

void closestpt( pt p1, pt p2, pt p3, pt &r ){
	// the closest point on the line $p_1 \rightarrow p_2$ to $p_3$
	if( fabs( triarea( p1, p2, p3 ) ) < EPS ){ 
		r = p3; return; 
	}
	pt v = p2-p1;
	v.normalize();
	dbl pr; //inner product
	pr = (p3.y-p1.y)*v.y + (p3.x-p1.x)*v.x;
	r = p1+v*pr;
}

//segments
dbl segDist(pt& s, pt& e, pt& p) {
	if (s==e) return (p-s).length();
	auto d = (e-s).length() * (e-s).length(), t = min(d,max(.0,dot((p-s),(e-s))));
	return ((p-s)*d-(e-s)*t).length()/d;
}
int segmentIntersection(pt& s1, pt& e1, pt& s2, pt& e2, pt& r1, pt& r2) {
	if (e1==s1) {
		if (e2==s2) {
			if (e1==e2) { r1 = e1; return 1; } //all equal
			else return 0; //different point segments
		} else return segmentIntersection(s2,e2,s1,e1,r1,r2);//swap
	}
	//segment directions and separation
	pt v1 = e1-s1, v2 = e2-s2, d = s2-s1;
	auto a = v1.cross(v2), a1 = v1.cross(d), a2 = v2.cross(d);
	if (a == 0) { //if parallel
		auto b1=s1.dot(v1), c1=e1.dot(v1),
		     b2=s2.dot(v1), c2=e2.dot(v1);
		if (a1 || a2 || max(b1,min(b2,c2))>min(c1,max(b2,c2)))
			return 0;
		r1 = min(b2,c2)<b1 ? s1 : (b2<c2 ? s2 : e2);
		r2 = max(b2,c2)>c1 ? e1 : (b2>c2 ? s2 : e2);
		return 2-(r1==r2);
	}
	if (a < 0) { a = -a; a1 = -a1; a2 = -a2; }
	if (0<a1 || a<-a1 || 0<a2 || a<-a2)
		return 0;
	r1 = s1-v1*a2/a;
	return 1;
}

int hcenter( pt p1, pt p2, pt p3, pt& r ){
	// point generated by altitudes
	if( triarea( p1, p2, p3 ) < EPS ) return -1;
	pt a1, a2;
	closestpt( p2, p3, p1, a1 );
	closestpt( p1, p3, p2, a2 );
	intersection( p1, a1, p2, a2, r );
	return 0;
}

int center( pt p1, pt p2, pt p3, pt& r ){
	// point generated by circumscribed circle
	if( triarea( p1, p2, p3 ) < EPS ) return -1;
	pt a1, a2, b1, b2;
	a1 = (p2+p3)*0.5;
	a2 = (p1+p3)*0.5;
	b1.x = a1.x - (p3.y-p2.y);
	b1.y = a1.y + (p3.x-p2.x);
	b2.x = a2.x - (p3.y-p1.y);
	b2.y = a2.y + (p3.x-p1.x);
	intersection( a1, b1, a2, b2, r );
	return 0;
}

int bcenter( pt p1, pt p2, pt p3, pt& r ){
	// angle bisection
	if( triarea( p1, p2, p3 ) < EPS ) return -1;
	dbl s1, s2, s3;
	s1 = dist( p2, p3 );
	s2 = dist( p1, p3 );
	s3 = dist( p1, p2 );
	
	
	dbl rt = s2/(s2+s3);
	pt a1,a2;
	a1 = p2*rt+p3*(1.0-rt);
	rt = s1/(s1+s3);
	a2 = p1*rt+p3*(1.0-rt);
	intersection( a1,p1, a2,p2, r );
	return 0;
}
// PONTS, LINES and CIRCLES
int pAndSeg(pt& p1, pt& p2, pt& p){
	// the relation of the point $p$ and the segment $p_1 \rightarrow p_2$.
	// returns: $1$ if point is on the segment, $0$ if not on the line,
	//         $-1$ if on the line but not on the segment
	dbl s=triarea(p, p1, p2);
	if(s>EPS) return(0);
	dbl sg=(p.x-p1.x)*(p.x-p2.x);
	if(sg>EPS) return(-1);
	sg=(p.y-p1.y)*(p.y-p2.y);
	if(sg>EPS) return(-1);
	return(1);
}

int lineAndCircle(pt& oo, dbl r, pt& p1, pt& p2, pt& r1, pt& r2){
	// returns: $-1$ if there is no intersection
	//           $1$ if there is only one intersection
	pt m;
	closestpt(p1,p2,oo,m);
	pt v = p2-p1;
	v.normalize();
	
	dbl r0=dist(oo, m);
	if(r0>r+EPS) return -1;
	if(fabs(r0-r)<EPS){
		r1=r2=m;
		return 1;
	}
	dbl dd = sqrt(r*r-r0*r0);
	r1 = m-v*dd; r2 = m+v*dd;
	return 0;
}


// ANGLES
dbl angle(pt& p1, pt& p2, pt& p3){
	// angle from $p_1 \rightarrow p_2$ to $p_1 \rightarrow p_3$, returns $-\pi$ to %\pi%
	pt va = p2-p1;
	va.normalize();
	pt vb; vb.x=-va.y; vb.y=va.x;
	pt v = p3-p1;
	dbl x,y;
	x=dot(v, va);
	y=dot(v, vb);
	return(atan2(y,x));
}

dbl angle(dbl a, dbl b, dbl c){ // $a^2 = b^2 + c^2 - 2bc\cos{\gamma}$
	// in a triangle with sides $a$,$b$,$c$, the angle between $b$ and $c$
	// we do not check if $a$,$b$,$c$ is a triangle here
	dbl cs=(b*b+c*c-a*a)/(2.0*b*c);
	return(acos(cs));
}

void rotate(pt p0, pt p1, dbl a, pt& r){
	// rotate p1 around $p_0$ clockwise, by angle $a$
	// donâ€™t pass by reference for p1, so r and p1 can be the same
	p1 = p1-p0;
	r.x = cos(a)*p1.x-sin(a)*p1.y;
	r.y = sin(a)*p1.x+cos(a)*p1.y;
	r = r+p0;
}

int CAndC(pt o1, dbl r1, pt o2, dbl r2, pt& q1, pt& q2){
	// returns: $-1$ if no intersection or infinite intersection
	//           $1$ if only one point

	dbl r=dist(o1,o2);
	if(r1<r2) { swap(o1,o2); swap(r1,r2); }
	if(r<EPS) return(-1);
	if(r>r1+r2+EPS) return(-1);
	if(r<r1-r2-EPS) return(-1);
	pt v = o2-o1; v.normalize();
	q1 = o1+v*r1;
	
	if(fabs(r-r1-r2)<EPS || fabs(r+r2-r1)<EPS){ 
		q2=q1; 
		return(1); 
	}
	dbl a=angle(r2, r, r1);
	q2=q1;
	rotate(o1, q1, a, q1);
	rotate(o1, q2, -a, q2);
	return 0;
}

int pAndPoly(vector<pt> pv, pt p){
	// returns: $1$ if $p$ is in pv, $0$ outside; $-1$ on the polygon
	int i, j;
	int n=pv.size();
	pv.push_back(pv[0]);
	for(i=0;i<n;i++)
		if(pAndSeg(pv[i], pv[i+1], p)==1) return(-1);
	for(i=0;i<n;i++)pv[i] = pv[i]-p;
	
	p.x=p.y=0.0;
	dbl a, y;
	
	while(1){
		a=(dbl)rand()/10000.00;
		j=0;
		for(i=0;i<n;i++){
			rotate(p, pv[i], a, pv[i]);
			if(fabs(pv[i].x)<EPS) j=1;
		}
		if(j==0){
			pv[n]=pv[0];
			j=0;
			for(i=0;i<n;i++) if(pv[i].x*pv[i+1].x < -EPS){
				y=pv[i+1].y-pv[i+1].x*(pv[i].y-pv[i+1].y)/(pv[i].x-pv[i+1].x);
				if (y>0) j++;
			}
			return(j%2);
		}
	}
	return 1;
}




void reflect(pt& p1, pt& p2, pt p3, pt& r){
	// $p_1 \rightarrow p_2$ line, reflect $p_3$ to get $r$.
	if(dist(p1, p3)<EPS) {r=p3; return;}
	dbl a=angle(p1, p2, p3);
	r=p3;
	rotate(p1, r, -2.0*a, r);
}

//points where the tangents touch the circle
template<class pt>
pair<pt,pt> circleTangents(const pt &p, const pt &c, dbl r) {
	pt a = p-c;
	dbl x = r*r/a.dist2(), y = sqrt(x-x*x);
	return make_pair(c+a*x+a.perp()*y, c+a*x-a.perp()*y);
//P perp() const { return P(-y, x); } // rotates +90 degrees
}

//circle instersection
bool circleIntersection(pt a, pt b, dbl r1, dbl r2,
		pair<pt, pt>* out) {
	pt delta = b - a;
	assert(delta.x || delta.y || r1 != r2);
	if (!delta.x && !delta.y) return false;
	dbl r = r1 + r2, d2 = delta.dist2();
	dbl p = (d2 + r1*r1 - r2*r2) / (2.0 * d2);
	dbl h2 = r1*r1 - p*p*d2;
	if (d2 > r*r || h2 < 0) return false;
	pt mid = a + delta*p, per = delta.perp() * sqrt(h2 / d2);
	*out = {mid + per, mid - per};
	return true;
}